import { Prisma, PrismaClient } from '@prisma/client';
import { db } from "./db";

export interface IStorage {
  // User operations
  getUser(id: string): Promise<Prisma.UserGetPayload<{}>>;
  getUserByUsername(username: string): Promise<Prisma.UserGetPayload<{}> | null>;
  createUser(user: Prisma.UserCreateInput): Promise<Prisma.UserGetPayload<{}>>;
  updateUserGithubToken(id: string, githubToken: string): Promise<Prisma.UserGetPayload<{}>>;

  // Website operations
  getWebsite(id: string): Promise<Prisma.WebsiteGetPayload<{}> | null>;
  getWebsitesByUserId(userId: string): Promise<Prisma.WebsiteGetPayload<{}>[]>;
  createWebsite(website: Prisma.WebsiteCreateInput): Promise<Prisma.WebsiteGetPayload<{}>>;
  updateWebsite(id: string, website: Prisma.WebsiteUpdateInput): Promise<Prisma.WebsiteGetPayload<{}> | null>;
  deleteWebsite(id: string): Promise<void>;

  // Article idea operations
  getArticleIdea(id: string): Promise<ArticleIdea | undefined>;
  getArticleIdeasByWebsiteId(websiteId: string): Promise<ArticleIdea[]>;
  getArticleIdeasByStatus(websiteId: string, status: string): Promise<ArticleIdea[]>;
  createArticleIdea(idea: InsertArticleIdea): Promise<ArticleIdea>;
  updateArticleIdea(id: string, idea: Partial<InsertArticleIdea>): Promise<ArticleIdea | undefined>;
  deleteArticleIdea(id: string): Promise<void>;

  // Draft operations
  getDraft(id: string): Promise<Draft | undefined>;
  getDraftsByWebsiteId(websiteId: string): Promise<Draft[]>;
  getDraftsByStatus(websiteId: string, status: string): Promise<Draft[]>;
  createDraft(draft: InsertDraft): Promise<Draft>;
  updateDraft(id: string, draft: Partial<InsertDraft>): Promise<Draft | undefined>;
  deleteDraft(id: string): Promise<void>;

  // Generation history operations
  getGenerationHistory(websiteId: string, limit?: number): Promise<GenerationHistory[]>;
  createGenerationHistory(history: InsertGenerationHistory): Promise<GenerationHistory>;
}

export class DbStorage implements IStorage {
  // User operations
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }

  async updateUserGithubToken(id: string, githubToken: string): Promise<User | undefined> {
    const [user] = await db
      .update(users)
      .set({ githubToken })
      .where(eq(users.id, id))
      .returning();
    return user;
  }

  // Website operations
  async getWebsite(id: string): Promise<Website | undefined> {
    const [website] = await db.select().from(websites).where(eq(websites.id, id));
    return website;
  }

  async getWebsitesByUserId(userId: string): Promise<Website[]> {
    return await db
      .select()
      .from(websites)
      .where(eq(websites.userId, userId))
      .orderBy(desc(websites.createdAt));
  }

  async createWebsite(website: InsertWebsite): Promise<Website> {
    const [newWebsite] = await db.insert(websites).values(website).returning();
    return newWebsite;
  }

  async updateWebsite(id: string, website: Partial<InsertWebsite>): Promise<Website | undefined> {
    const [updated] = await db
      .update(websites)
      .set({ ...website, updatedAt: new Date() })
      .where(eq(websites.id, id))
      .returning();
    return updated;
  }

  async deleteWebsite(id: string): Promise<void> {
    await db.delete(websites).where(eq(websites.id, id));
  }

  // Article idea operations
  async getArticleIdea(id: string): Promise<ArticleIdea | undefined> {
    const [idea] = await db.select().from(articleIdeas).where(eq(articleIdeas.id, id));
    return idea;
  }

  async getArticleIdeasByWebsiteId(websiteId: string): Promise<ArticleIdea[]> {
    return await db
      .select()
      .from(articleIdeas)
      .where(eq(articleIdeas.websiteId, websiteId))
      .orderBy(desc(articleIdeas.createdAt));
  }

  async getArticleIdeasByStatus(websiteId: string, status: string): Promise<ArticleIdea[]> {
    return await db
      .select()
      .from(articleIdeas)
      .where(and(eq(articleIdeas.websiteId, websiteId), eq(articleIdeas.status, status as any)))
      .orderBy(desc(articleIdeas.createdAt));
  }

  async createArticleIdea(idea: InsertArticleIdea): Promise<ArticleIdea> {
    const [newIdea] = await db.insert(articleIdeas).values(idea).returning();
    return newIdea;
  }

  async updateArticleIdea(id: string, idea: Partial<InsertArticleIdea>): Promise<ArticleIdea | undefined> {
    const [updated] = await db
      .update(articleIdeas)
      .set(idea)
      .where(eq(articleIdeas.id, id))
      .returning();
    return updated;
  }

  async deleteArticleIdea(id: string): Promise<void> {
    await db.delete(articleIdeas).where(eq(articleIdeas.id, id));
  }

  // Draft operations
  async getDraft(id: string): Promise<Draft | undefined> {
    const [draft] = await db.select().from(drafts).where(eq(drafts.id, id));
    return draft;
  }

  async getDraftsByWebsiteId(websiteId: string): Promise<Draft[]> {
    return await db
      .select()
      .from(drafts)
      .where(eq(drafts.websiteId, websiteId))
      .orderBy(desc(drafts.createdAt));
  }

  async getDraftsByStatus(websiteId: string, status: string): Promise<Draft[]> {
    return await db
      .select()
      .from(drafts)
      .where(and(eq(drafts.websiteId, websiteId), eq(drafts.status, status as any)))
      .orderBy(desc(drafts.createdAt));
  }

  async createDraft(draft: InsertDraft): Promise<Draft> {
    const [newDraft] = await db.insert(drafts).values(draft).returning();
    return newDraft;
  }

  async updateDraft(id: string, draft: Partial<InsertDraft>): Promise<Draft | undefined> {
    const [updated] = await db
      .update(drafts)
      .set({ ...draft, updatedAt: new Date() })
      .where(eq(drafts.id, id))
      .returning();
    return updated;
  }

  async deleteDraft(id: string): Promise<void> {
    await db.delete(drafts).where(eq(drafts.id, id));
  }

  // Generation history operations
  async getGenerationHistory(websiteId: string, limit: number = 50): Promise<GenerationHistory[]> {
    return await db
      .select()
      .from(generationHistory)
      .where(eq(generationHistory.websiteId, websiteId))
      .orderBy(desc(generationHistory.createdAt))
      .limit(limit);
  }

  async createGenerationHistory(history: InsertGenerationHistory): Promise<GenerationHistory> {
    const [newHistory] = await db.insert(generationHistory).values(history).returning();
    return newHistory;
  }
}

// If the real DB is not available (e.g. running locally without DATABASE_URL),
// provide an in-memory implementation so the server can start for preview/demo.
const hasRealDb = typeof (db as any)?.select === 'function';

class MemoryStorage implements IStorage {
  private users = new Map<string, User>();
  private websites = new Map<string, Website>();
  private articleIdeas = new Map<string, ArticleIdea>();
  private drafts = new Map<string, Draft>();
  private generationHistory = new Map<string, GenerationHistory[]>();

  private makeId(prefix = '') {
    return prefix + Math.random().toString(36).slice(2, 9);
  }

  // User operations
  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    for (const u of this.users.values()) {
      if ((u as any).username === username) return u;
    }
    return undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.makeId('u_');
    const now = new Date();
    const user = { id, createdAt: now, updatedAt: now, ...insertUser } as User;
    this.users.set(id, user);
    return user;
  }

  async updateUserGithubToken(id: string, githubToken: string): Promise<User | undefined> {
    const u = this.users.get(id);
    if (!u) return undefined;
    const updated = { ...u, githubToken, updatedAt: new Date() } as User;
    this.users.set(id, updated);
    return updated;
  }

  // Website operations
  async getWebsite(id: string): Promise<Website | undefined> {
    return this.websites.get(id);
  }

  async getWebsitesByUserId(userId: string): Promise<Website[]> {
    return Array.from(this.websites.values()).filter(w => (w as any).userId === userId);
  }

  async createWebsite(website: InsertWebsite): Promise<Website> {
    const id = this.makeId('w_');
    const now = new Date();
    const w = { id, createdAt: now, updatedAt: now, ...website } as Website;
    this.websites.set(id, w);
    return w;
  }

  async updateWebsite(id: string, website: Partial<InsertWebsite>): Promise<Website | undefined> {
    const w = this.websites.get(id);
    if (!w) return undefined;
    const updated = { ...w, ...website, updatedAt: new Date() } as Website;
    this.websites.set(id, updated);
    return updated;
  }

  async deleteWebsite(id: string): Promise<void> {
    this.websites.delete(id);
  }

  // Article idea operations (simple implementations)
  async getArticleIdea(id: string): Promise<ArticleIdea | undefined> {
    return this.articleIdeas.get(id);
  }

  async getArticleIdeasByWebsiteId(websiteId: string): Promise<ArticleIdea[]> {
    return Array.from(this.articleIdeas.values()).filter(a => (a as any).websiteId === websiteId);
  }

  async getArticleIdeasByStatus(websiteId: string, status: string): Promise<ArticleIdea[]> {
    return Array.from(this.articleIdeas.values()).filter(a => (a as any).websiteId === websiteId && (a as any).status === status);
  }

  async createArticleIdea(idea: InsertArticleIdea): Promise<ArticleIdea> {
    const id = this.makeId('ai_');
    const now = new Date();
    const obj = { id, createdAt: now, updatedAt: now, ...idea } as ArticleIdea;
    this.articleIdeas.set(id, obj);
    return obj;
  }

  async updateArticleIdea(id: string, idea: Partial<InsertArticleIdea>): Promise<ArticleIdea | undefined> {
    const a = this.articleIdeas.get(id);
    if (!a) return undefined;
    const updated = { ...a, ...idea, updatedAt: new Date() } as ArticleIdea;
    this.articleIdeas.set(id, updated);
    return updated;
  }

  async deleteArticleIdea(id: string): Promise<void> {
    this.articleIdeas.delete(id);
  }

  // Draft operations
  async getDraft(id: string): Promise<Draft | undefined> {
    return this.drafts.get(id);
  }

  async getDraftsByWebsiteId(websiteId: string): Promise<Draft[]> {
    return Array.from(this.drafts.values()).filter(d => (d as any).websiteId === websiteId);
  }

  async getDraftsByStatus(websiteId: string, status: string): Promise<Draft[]> {
    return Array.from(this.drafts.values()).filter(d => (d as any).websiteId === websiteId && (d as any).status === status);
  }

  async createDraft(draft: InsertDraft): Promise<Draft> {
    const id = this.makeId('d_');
    const now = new Date();
    const obj = { id, createdAt: now, updatedAt: now, ...draft } as Draft;
    this.drafts.set(id, obj);
    return obj;
  }

  async updateDraft(id: string, draft: Partial<InsertDraft>): Promise<Draft | undefined> {
    const d = this.drafts.get(id);
    if (!d) return undefined;
    const updated = { ...d, ...draft, updatedAt: new Date() } as Draft;
    this.drafts.set(id, updated);
    return updated;
  }

  async deleteDraft(id: string): Promise<void> {
    this.drafts.delete(id);
  }

  // Generation history
  async getGenerationHistory(websiteId: string, limit: number = 50): Promise<GenerationHistory[]> {
    const arr = this.generationHistory.get(websiteId) || [];
    return arr.slice(0, limit);
  }

  async createGenerationHistory(history: InsertGenerationHistory): Promise<GenerationHistory> {
    const id = this.makeId('gh_');
    const now = new Date();
    const obj = { id, createdAt: now, ...history } as GenerationHistory;
    const arr = this.generationHistory.get(history.websiteId) || [];
    arr.unshift(obj);
    this.generationHistory.set(history.websiteId, arr);
    return obj;
  }
}

export const storage: IStorage = hasRealDb ? new DbStorage() : new MemoryStorage();
