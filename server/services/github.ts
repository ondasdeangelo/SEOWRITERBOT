import { Octokit } from "@octokit/rest";
import type { Draft, Website } from "@shared/schema";

export class GitHubService {
  private octokit: Octokit;

  constructor(token: string) {
    this.octokit = new Octokit({
      auth: token,
    });
  }

  async createPullRequest(
    draft: Draft,
    website: Website
  ): Promise<string> {
    if (!website.githubRepo) {
      throw new Error("GitHub repository not configured for this website");
    }

    // Parse owner/repo from githubRepo
    const [owner, repo] = website.githubRepo.split("/");
    if (!owner || !repo) {
      throw new Error("Invalid GitHub repository format. Expected: owner/repo");
    }

    const branch = website.githubBranch || "main";
    const basePath = website.githubPath || "blog";
    
    // Create a new branch for this article
    const newBranchName = `article/${this.slugify(draft.title)}-${Date.now()}`;

    // Get the reference of the base branch
    const { data: refData } = await this.octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${branch}`,
    });

    // Create a new branch
    await this.octokit.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${newBranchName}`,
      sha: refData.object.sha,
    });

    // Create the MDX file content with frontmatter
    const frontmatter = this.generateFrontmatter(draft);
    const mdxContent = `---\n${frontmatter}\n---\n\n${draft.content}`;

    // Create the file in the new branch
    const fileName = `${this.slugify(draft.title)}.mdx`;
    const filePath = `${basePath}/${fileName}`;

    await this.octokit.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: filePath,
      message: `Add article: ${draft.title}`,
      content: Buffer.from(mdxContent).toString("base64"),
      branch: newBranchName,
    });

    // Create pull request
    const { data: pr } = await this.octokit.pulls.create({
      owner,
      repo,
      title: `New Article: ${draft.title}`,
      head: newBranchName,
      base: branch,
      body: `## üìù New Article Draft\n\n**Title:** ${draft.title}\n\n**Excerpt:** ${draft.excerpt}\n\n**Stats:**\n- Word Count: ${draft.wordCount}\n- Readability Score: ${draft.readabilityScore}/100\n- Keyword Density: ${draft.keywordDensity}%\n\n---\n\nGenerated by SEO Blog Generator Bot`,
    });

    return pr.html_url;
  }

  private generateFrontmatter(draft: Draft): string {
    const frontmatter = draft.frontmatter as Record<string, any> || {};
    
    const fm: Record<string, any> = {
      title: draft.title,
      description: draft.excerpt,
      date: new Date().toISOString().split('T')[0],
      ...frontmatter,
    };

    return Object.entries(fm)
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return `${key}:\n${value.map(v => `  - ${v}`).join('\n')}`;
        } else if (typeof value === 'string' && value.includes('\n')) {
          return `${key}: |\n  ${value.split('\n').join('\n  ')}`;
        } else if (typeof value === 'string') {
          return `${key}: "${value}"`;
        } else {
          return `${key}: ${value}`;
        }
      })
      .join('\n');
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/--+/g, '-')
      .trim();
  }
}

export function createGitHubService(token: string): GitHubService {
  return new GitHubService(token);
}
